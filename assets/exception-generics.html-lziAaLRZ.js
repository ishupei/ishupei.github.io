import{_ as e,c as o,b as r,o as n}from"./app-Bmvlbfib.js";const c={};function i(s,t){return n(),o("div",null,t[0]||(t[0]=[r('<h2 id="异常" tabindex="-1"><a class="header-anchor" href="#异常"><span>异常</span></a></h2><p>Java的所有异常和错误都继承自 <code>java.lang.Throwable</code>类。分为两大分支：</p><ol><li><strong>Error</strong>：系统级错误，程序无法处理（如<code>OutOfMemoryError</code>）</li><li><strong>Exception</strong>：程序可处理的异常 <ul><li><strong>Checked Exception</strong>：编译时强制检查、必须被捕获或声明抛出（如<code>IOException</code>、<code>ClassNotFoundException</code>）</li><li><strong>Unchecked Exception</strong>：运行时异常、不强制处理（如<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>ClassCastException</code>）</li></ul></li></ol><figure><img src="https://gitee.com/ishupei/picgo_img/raw/master/typora/image-20250904233633905.png" alt="异常继承关系图" tabindex="0" loading="lazy"><figcaption>异常继承关系图</figcaption></figure><p><strong>异常处理关键字</strong></p><ul><li><p><strong>try</strong>：包裹可能发生异常的代码块。</p></li><li><p><strong>catch</strong>：捕获特定类型的异常并进行处理。可以有多个catch块，<strong>子类异常必须写在父类前面</strong>（否则会编译错误）。</p></li><li><p><strong>finally</strong>：无论是否发生异常，<strong>必定会执行的代码块</strong>。常用于释放资源（如关闭文件、网络连接）。</p></li><li><p><strong>throw</strong>：在方法内部手动抛出一个异常对象。</p></li><li><p><strong>throws</strong>：在方法声明上，指明该方法可能抛出的异常类型，通知调用者需要处理。</p></li></ul><table><thead><tr><th style="text-align:center;">特性</th><th style="text-align:center;">throw</th><th style="text-align:center;">throws</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>作用</strong></td><td style="text-align:center;">主动抛出一个具体的异常对象</td><td style="text-align:center;">声明方法可能抛出的异常类型</td></tr><tr><td style="text-align:center;"><strong>语法位置</strong></td><td style="text-align:center;">方法内部使用</td><td style="text-align:center;">方法签名末尾使用</td></tr><tr><td style="text-align:center;"><strong>数量</strong></td><td style="text-align:center;">一次只能抛出一个异常对象</td><td style="text-align:center;">可以声明多个异常类型（逗号分隔）</td></tr><tr><td style="text-align:center;"><strong>处理方式</strong></td><td style="text-align:center;">必须配合try-catch或throws使用</td><td style="text-align:center;">调用者必须处理（try-catch或继续throws）</td></tr></tbody></table><p><strong>Error和Exception的区别？</strong></p><blockquote><p>Error是程序无法处理的严重系统错误，如OOM，应用程序无需捕获。Exception是程序可以处理的异常，分为受检异常（必须处理）和非受检异常（运行时异常，可不处理）。</p></blockquote><p><strong>Checked Exception和Unchecked Exception的区别？</strong></p><blockquote><ul><li><strong>受检异常</strong>：编译器强制检查，必须用<code>try-catch</code>捕获或用<code>throws</code>声明抛出。通常是由外部因素（如I/O错误、文件不存在）导致的可恢复问题。</li><li><strong>非受检异常</strong>：编译器不检查，无需强制处理。通常是程序逻辑错误（如空指针、数组越界），属于不可恢复的错误。</li></ul></blockquote><p><strong>finally块一定会执行吗？什么情况下不执行？</strong></p><blockquote><p>几乎一定会执行。只有在以下极端情况下不会：</p><ul><li>System.exit()被调用</li><li>线程死亡</li><li>JVM崩溃</li><li>服务器断电、系统崩溃等物理原因。</li></ul></blockquote><p><strong>在finally块中写return语句会怎样？</strong></p><blockquote><p><strong>严禁这样做</strong>。它会覆盖<code>try</code>或<code>catch</code>块中的返回值，并抑制其他异常的抛出，导致极其隐蔽的BUG，且编译器会产生警告。</p></blockquote><p><strong>try-catch-finally的执行顺序？如果catch中又抛出了异常呢？</strong></p><blockquote><p>顺序是 <code>try</code>-&gt; 如果发生异常则进入匹配的 <code>catch</code>-&gt; <strong>最后必定执行 <code>finally</code></strong>。如果在<code>catch</code>中抛出了新异常，这个新异常会在<code>finally</code>执行完后才被抛出。</p></blockquote><p><strong>什么是异常链？有什么好处？</strong></p><blockquote><p>异常链是将捕获的原始异常作为原因（Cause）传递给新的异常。好处是能保留完整的异常堆栈信息，便于追踪问题的根本原因，不会因为抛出新的业务异常而丢失底层的详细错误。</p></blockquote><p><strong>用过try-with-resources吗？它有什么好处？</strong></p><blockquote><p>它用于自动管理资源，确保每个资源在语句结束时都被正确关闭。好处是代码更简洁，避免了繁琐的<code>finally</code>块和手动关闭，并且能更好地处理“关闭异常”（ suppressed exceptions）。</p></blockquote><p><strong>异常使用注意点</strong></p><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常，比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决</li></ul><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型"><span>泛型</span></a></h2><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错</p><p><strong>类型擦除</strong></p><ol><li><p><strong>编译时检查，运行时擦除</strong>：泛型信息只存在于编译阶段，运行时JVM看到的都是原始类型（Raw Type）</p></li><li><p><strong>擦除规则</strong>：</p><ul><li>无界类型参数<code>&lt;T&gt;</code> → <code>Object</code></li><li>有界类型参数<code>&lt;T extends Number&gt;</code> → <code>Number</code></li><li>泛型方法参数类型同样被擦除</li></ul></li></ol>',28)]))}const a=e(c,[["render",i]]),p=JSON.parse(`{"path":"/java/basic/exception-generics.html","title":"异常与泛型","lang":"zh-CN","frontmatter":{"title":"异常与泛型","category":"Java","tag":["Java基础"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"异常与泛型\\",\\"image\\":[\\"https://gitee.com/ishupei/picgo_img/raw/master/typora/image-20250904233633905.png\\"],\\"dateModified\\":\\"2025-09-04T16:37:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HuPei\\",\\"url\\":\\"https://ishupei.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://ishupei.github.io/java/basic/exception-generics.html"}],["meta",{"property":"og:site_name","content":"hupei's page"}],["meta",{"property":"og:title","content":"异常与泛型"}],["meta",{"property":"og:description","content":"异常 Java的所有异常和错误都继承自 java.lang.Throwable类。分为两大分支： Error：系统级错误，程序无法处理（如OutOfMemoryError） Exception：程序可处理的异常 Checked Exception：编译时强制检查、必须被捕获或声明抛出（如IOException、ClassNotFoundExceptio..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://gitee.com/ishupei/picgo_img/raw/master/typora/image-20250904233633905.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-04T16:37:23.000Z"}],["meta",{"property":"article:tag","content":"Java基础"}],["meta",{"property":"article:modified_time","content":"2025-09-04T16:37:23.000Z"}]],"description":"异常 Java的所有异常和错误都继承自 java.lang.Throwable类。分为两大分支： Error：系统级错误，程序无法处理（如OutOfMemoryError） Exception：程序可处理的异常 Checked Exception：编译时强制检查、必须被捕获或声明抛出（如IOException、ClassNotFoundExceptio..."},"git":{"createdTime":1756984917000,"updatedTime":1757003843000,"contributors":[{"name":"hupei","username":"hupei","email":"ishupei@qq.com","commits":3,"url":"https://github.com/hupei"}]},"readingTime":{"minutes":4.33,"words":1300},"filePathRelative":"java/basic/exception-generics.md","autoDesc":true}`);export{a as comp,p as data};
