import{_ as t,c as o,b as a,o as r}from"./app-Bmvlbfib.js";const s={};function p(n,e){return r(),o("div",null,e[0]||(e[0]=[a('<h2 id="hashmap底层实现" tabindex="-1"><a class="header-anchor" href="#hashmap底层实现"><span>HashMap底层实现</span></a></h2><p>HashMap 基于 <strong>数组 + 链表 + 红黑树</strong> 实现。<br><strong>核心原理：</strong></p><ol><li><strong>存值 (put)：</strong> 先用 key 的 <code>hashCode()</code> 经过<strong>扰动计算</strong>（(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)）得到 hash 值，再用 <code>(n - 1) &amp; hash</code> 确定数组下标。如果目标桶为空则直接插入；若不为空，则遍历该桶的链表或树：若找到相同 key 则覆盖 value，否则将新节点插入链表尾部或树中。</li><li><strong>取值 (get)：</strong> 类似 put 过程，计算 hash 和下标后，遍历该桶的链表或树查找 key。</li><li><strong>扩容 (resize)：</strong> 当元素数量超过（容量 * 负载因子(默认0.75)）时，数组扩容为原来的 2 倍，并重新排列所有元素。</li></ol><p><strong>JDK8 优化：</strong></p><ol><li><p><strong>红黑树：</strong> 当链表长度 &gt; 8 <strong>且</strong> 数组容量 ≥ 64 时，链表转为红黑树，解决哈希冲突严重时链表查询慢(O(n))的问题，将查询效率提升至 O(log n)。节点数小于 6 时退化为链表。</p></li><li><p><strong>尾插法：</strong> 插入链表时改用尾插法（JDK7是头插法），避免了多线程环境下扩容时可能产生的死循环问题。</p></li><li><p><strong>扩容优化：</strong> 扩容时，元素的新位置要么是<strong>原位置</strong>，要么是<strong>原位置+旧容量</strong>。通过 <code>(e.hash &amp; oldCap) == 0</code> 一位判断即可，无需重新计算 hash，提升了 rehash 效率。</p></li><li><p><strong>hash() 简化：</strong> 扰动函数计算比 JDK7 更简洁，性能略有提升。</p></li></ol><h2 id="hashmap遍历" tabindex="-1"><a class="header-anchor" href="#hashmap遍历"><span>HashMap遍历</span></a></h2><p>我们不能在遍历中使用集合 <code>map.remove()</code> 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 <code>iterator.remove()</code> 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p><p>HashMap 4 种遍历方式：迭代器、for、lambda、stream，以及具体的 7 种遍历方法，综合性能和安全性来看，<strong>我们应该尽量使用迭代器（Iterator）来遍历 <code>EntrySet</code> 的遍历方式来操作 Map 集合</strong>，这样就会既安全又高效了。HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p><ol><li>迭代器（Iterator）方式遍历；</li><li>For Each 方式遍历；</li><li>Lambda 表达式遍历（JDK 1.8+）; <ol><li>Streams API 遍历（JDK 1.8+）。</li></ol></li></ol><p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><ol><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ol><p>接下来我们来看每种遍历方式的具体实现代码。</p><p><strong>性能分析</strong></p><p><code>EntrySet</code> 之所以比 <code>KeySet</code> 的性能高是因为，<code>KeySet</code> 在循环时使用了 <code>map.get(key)</code>，而 <code>map.get(key)</code> 相当于又遍历了一遍 Map 集合去查询 <code>key</code> 所对应的值。为什么要用“又”这个词？那是因为<strong>在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 <code>map.get(key)</code> 查询时，相当于遍历了两遍</strong>。</p><p>而 <code>EntrySet</code> 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry = iterator.next()”把对象的 <code>key</code> 和 <code>value</code> 值都放入到了 <code>Entry</code> 对象中，因此再获取 <code>key</code> 和 <code>value</code> 值时就无需再遍历 Map 集合，只需要从 <code>Entry</code> 对象中取值就可以了。</p><p>所以，<strong><code>EntrySet</code> 的性能比 <code>KeySet</code> 的性能高出了一倍，因为 <code>KeySet</code> 相当于循环了两遍 Map 集合，而 <code>EntrySet</code> 只循环了一遍</strong>。</p><p>使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法， 它的add/remove/clear方法会抛出<code>UnsupportedOperationException</code>异常。Arrays.asList()方法返回的并不是java.util.ArrayList，而是java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>',17)]))}const i=t(s,[["render",p]]),h=JSON.parse(`{"path":"/java/basic/collection/hashmap.html","title":"HashMap详解","lang":"zh-CN","frontmatter":{"title":"HashMap详解","category":"Java","tag":["集合"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-04T16:37:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HuPei\\",\\"url\\":\\"https://ishupei.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://ishupei.github.io/java/basic/collection/hashmap.html"}],["meta",{"property":"og:site_name","content":"hupei's page"}],["meta",{"property":"og:title","content":"HashMap详解"}],["meta",{"property":"og:description","content":"HashMap底层实现 HashMap 基于 数组 + 链表 + 红黑树 实现。 核心原理： 存值 (put)： 先用 key 的 hashCode() 经过扰动计算（(h = key.hashCode()) ^ (h >>> 16)）得到 hash 值，再用 (n - 1) & hash 确定数组下标。如果目标桶为空则直接插入；若不为空，则遍历该桶的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-04T16:37:23.000Z"}],["meta",{"property":"article:tag","content":"集合"}],["meta",{"property":"article:modified_time","content":"2025-09-04T16:37:23.000Z"}]],"description":"HashMap底层实现 HashMap 基于 数组 + 链表 + 红黑树 实现。 核心原理： 存值 (put)： 先用 key 的 hashCode() 经过扰动计算（(h = key.hashCode()) ^ (h >>> 16)）得到 hash 值，再用 (n - 1) & hash 确定数组下标。如果目标桶为空则直接插入；若不为空，则遍历该桶的..."},"git":{"createdTime":1757003843000,"updatedTime":1757003843000,"contributors":[{"name":"hupei","username":"hupei","email":"ishupei@qq.com","commits":1,"url":"https://github.com/hupei"}]},"readingTime":{"minutes":3.62,"words":1086},"filePathRelative":"java/basic/collection/hashmap.md","autoDesc":true}`);export{i as comp,h as data};
