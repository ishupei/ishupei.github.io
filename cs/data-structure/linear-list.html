<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.21" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.82" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"线性表","image":["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUUAAACeCAYAAACl+hgFAAAgAElEQVR4Ae3dB7Q2VXU3cNZyfVmJK81oxEgiNgwosYJBxCAGLCAGUcDeRVQEFQsqWFBsKKLYCYqCoqAI9oKCIhJ7V1Swgb3GlhiTzLd+o/uu8847ZZ+XO3mfy33OWs8zZ878z96nzPxnnzpb/O///m+TcVkcWTXYjO5amVn9Wdxa0395K9NlPeWe0Zr7dK4y3Zz3Xlb3VDlt8T//8z8tiSmksV8WR0YNdkxnea1GZhabxdXmKSs3i6vVX5bbmH8O/WtFZk2ZzpGnsXrpXptD/xwyu+keO19k/VtIeMZlcVMsnNHVh5lD/xwya/I/l/6+8usLm0P/WpG5rKfcc19TTn332FDYHPfJkK6+8DH9S1LsK7GesLFC7MKz2CyO/BpsNz1D5zUys9gsriZPc8hcBP1D9dINnyP/c8jspnvsfJH1L0lxrOaKa3NU4hwyiyRPeufQv1ZkKpxsWrO4GpmTlVMA5tA/h8wiyZPeRda/JMXJ6vs9YI5KnENmMjstbA79a0WmAsimNYurkXl5rKfNnafV0r8caJkYYPJA+M3RMTyHzEhv5jiH/rUis6ZO58hTpn4CM4f+OWRGejPHRda/tBSTrxcVnXVZbBZHbw12tdNZo78mnVlsFleTzhrsXPovb/WUzU9N2ddis2kYq9MlKSZLcawQuyKy2Cxuc9wYi5SnucopKzeLW+/11L1nxs4XuUyXpDhWc8W1OSpxDplFkie9c+hfKzIVTjatWVyNzMnKKQBz6J9DZpHkSe8i61+S4mT1/R4wRyXOITOZnRY2h/61IlMBZNOaxdXIvDzW0+bO02rpXw60rNJAy69//evml7/8Ze+gzGc+85k23MNV/nQ2/+xnP2sOP/zw5ic/+ckG10ocf7dj+qlPfWrzrW99azSOeGeddVbzu9/9bgPc85///OanP/3pRjK7Osvzrv7yWunP4sTJYrO4Gpk12Ln0l+U25p9D/xwyx/LQvbbI+peWYvL1olK77hWveEVzwQUXNJ/73Oear33ta82+++7bPOMZz2he/vKXN3e7292aI488soFBep/61KdWor/vfe9rSQkRIqfjjz++edWrXtX6nX/3u99t7n//+zff//732zj/+Z//2ZKma34XX3xxc5Ob3KQ9RpgjOT/60Y9W9CDpbbbZpk3fb3/725XwnXbaqfnFL37REiVZGdeX/754WZy4WWwWVyOzi1XGfe6//uu/mqFr8B/84AebT3/60ytRM2n9zW9+07zrXe9q/vu//3sl3pgnIzPiZ7FZHLk12EjH1LFGZg12Sm9cH5O5JMUopYljXyE+7nGPawlnl112aT72sY81z3nOc1assnvd616Nm5/rPlQ3vOENm1NOOaV54xvf2Pt7/etf34Z/5StfaeOfd955zYknnriCve1tb9uSb1/8r371qys5ee1rX9sce+yxzSc+8Ynm4Q9/eEuyH/jAB5rtt9++Oeqoo1ryvu51r9v8+7//+0qcIU9f/vuwWZy4WWwWVyNTnSifcMr0ec97XvPCF76wefWrX90cccQRzUknndQ84QlPaJ7ylKcErPn5z3/elC8YL56dd955heCk1QuwJMqVyH/weBne+MY3bhBuuM9+9rPtiyrOy+Mc+Z9DZpnmKf8i61+SYqf2ugQWl/sqESmy0O50pzu1liJS9KB5kA4++ODWSnzWs57V7L777isPDXnXv/71m2984xvNoYce2mJYk/HTLL7RjW7UvPe97w3V7TH0ewj32muvRnP9P/7jP5pf/epXrR+B/uAHP9ggzq1udasVwnvoQx/akvO3v/3thqUo/p577tlccsklG8QZOgn9Q9cjPIuDz2KzuBqZ8r/33nu3L5vXve51ze1ud7vIQuMl9IIXvKA9j66HuOilovyjvhy9YF784he3YVoJRx99dEuwEUfLoMSTfYMb3KANixfg4x//+PalF3HK4xz5n0NmmeYp/yLrX5Ji07SExRJDIle5ylV63/J9lRik6IHSb4gU3/CGNzSnnnpq88UvfrElHJbbAQccsME9Eg8gmZrdHkoE9573vKd5xCMe0T6UXYKD1TS+733v2z7IL33pS5u3vvWtzTve8Y72yPr0MIb7whe+0Py///f/2ma3MA83Amel7LPPPm2T/ulPf3qbVg/tlOvLf1+cLE7cLDaLq5GJFB/5yEe2lvTJJ5/c3PrWt24tey8qVr6yQWR3vvOdm4985CMrWUWKhx12WPPxj3+8ec1rXrMB2cG7B0444YQNXoIiq19l76d7xAspzlmW6nLIzZH/OWQOpb8vfJH1r3tS1K/zsIc9rG3OeBDe/va3b9TcVal9lRik6IEqSRHBIsYHPehBDVLUP1g65FvK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"],"dateModified":"2025-09-04T11:21:57.000Z","author":[{"@type":"Person","name":"HuPei","url":"https://ishupei.github.io"}]}</script><meta property="og:url" content="https://ishupei.github.io/cs/data-structure/linear-list.html"><meta property="og:site_name" content="hupei's page"><meta property="og:title" content="线性表"><meta property="og:description" content="线性表 2.1 线性表的定义和基本操作 定义：线性表是具有相同数据类型的n (n≥0)个数据元素的有限序列，其中n为表长，当n =0时线性表是一个空表。 图片图片 2.2 线性表的顺序表示 2.2.1 顺序表的实现 线性表的顺序存储称为顺序表。特点是表中元素的逻辑顺序与其物理顺序相同，是一种随机存取的数据结构，通常用高级程序设计语言中的数组来描述线性表..."><meta property="og:type" content="article"><meta property="og:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUUAAACeCAYAAACl+hgFAAAgAElEQVR4Ae3dB7Q2VXU3cNZyfVmJK81oxEgiNgwosYJBxCAGLCAGUcDeRVQEFQsqWFBsKKLYCYqCoqAI9oKCIhJ7V1Swgb3GlhiTzLd+o/uu8847ZZ+XO3mfy33OWs8zZ878z96nzPxnnzpb/O///m+TcVkcWTXYjO5amVn9Wdxa0395K9NlPeWe0Zr7dK4y3Zz3Xlb3VDlt8T//8z8tiSmksV8WR0YNdkxnea1GZhabxdXmKSs3i6vVX5bbmH8O/WtFZk2ZzpGnsXrpXptD/xwyu+keO19k/VtIeMZlcVMsnNHVh5lD/xwya/I/l/6+8usLm0P/WpG5rKfcc19TTn332FDYHPfJkK6+8DH9S1LsK7GesLFC7MKz2CyO/BpsNz1D5zUys9gsriZPc8hcBP1D9dINnyP/c8jspnvsfJH1L0lxrOaKa3NU4hwyiyRPeufQv1ZkKpxsWrO4GpmTlVMA5tA/h8wiyZPeRda/JMXJ6vs9YI5KnENmMjstbA79a0WmAsimNYurkXl5rKfNnafV0r8caJkYYPJA+M3RMTyHzEhv5jiH/rUis6ZO58hTpn4CM4f+OWRGejPHRda/tBSTrxcVnXVZbBZHbw12tdNZo78mnVlsFleTzhrsXPovb/WUzU9N2ddis2kYq9MlKSZLcawQuyKy2Cxuc9wYi5SnucopKzeLW+/11L1nxs4XuUyXpDhWc8W1OSpxDplFkie9c+hfKzIVTjatWVyNzMnKKQBz6J9DZpHkSe8i61+S4mT1/R4wRyXOITOZnRY2h/61IlMBZNOaxdXIvDzW0+bO02rpXw60rNJAy69//evml7/8Ze+gzGc+85k23MNV/nQ2/+xnP2sOP/zw5ic/+ckG10ocf7dj+qlPfWrzrW99azSOeGeddVbzu9/9bgPc85///OanP/3pRjK7Osvzrv7yWunP4sTJYrO4Gpk12Ln0l+U25p9D/xwyx/LQvbbI+peWYvL1olK77hWveEVzwQUXNJ/73Oear33ta82+++7bPOMZz2he/vKXN3e7292aI488soFBep/61KdWor/vfe9rSQkRIqfjjz++edWrXtX6nX/3u99t7n//+zff//732zj/+Z//2ZKma34XX3xxc5Ob3KQ9RpgjOT/60Y9W9CDpbbbZpk3fb3/725XwnXbaqfnFL37REiVZGdeX/754WZy4WWwWVyOzi1XGfe6//uu/mqFr8B/84AebT3/60ytRM2n9zW9+07zrXe9q/vu//3sl3pgnIzPiZ7FZHLk12EjH1LFGZg12Sm9cH5O5JMUopYljXyE+7nGPawlnl112aT72sY81z3nOc1assnvd616Nm5/rPlQ3vOENm1NOOaV54xvf2Pt7/etf34Z/5StfaeOfd955zYknnriCve1tb9uSb1/8r371qys5ee1rX9sce+yxzSc+8Ynm4Q9/eEuyH/jAB5rtt9++Oeqoo1ryvu51r9v8+7//+0qcIU9f/vuwWZy4WWwWVyNTnSifcMr0ec97XvPCF76wefWrX90cccQRzUknndQ84QlPaJ7ylKcErPn5z3/elC8YL56dd955heCk1QuwJMqVyH/weBne+MY3bhBuuM9+9rPtiyrOy+Mc+Z9DZpnmKf8i61+SYqf2ugQWl/sqESmy0O50pzu1liJS9KB5kA4++ODWSnzWs57V7L777isPDXnXv/71m2984xvNoYce2mJYk/HTLL7RjW7UvPe97w3V7TH0ewj32muvRnP9P/7jP5pf/epXrR+B/uAHP9ggzq1udasVwnvoQx/akvO3v/3thqUo/p577tlccsklG8QZOgn9Q9cjPIuDz2KzuBqZ8r/33nu3L5vXve51ze1ud7vIQuMl9IIXvKA9j66HuOilovyjvhy9YF784he3YVoJRx99dEuwEUfLoMSTfYMb3KANixfg4x//+PalF3HK4xz5n0NmmeYp/yLrX5Ji07SExRJDIle5ylV63/J9lRik6IHSb4gU3/CGNzSnnnpq88UvfrElHJbbAQccsME9Eg8gmZrdHkoE9573vKd5xCMe0T6UXYKD1TS+733v2z7IL33pS5u3vvWtzTve8Y72yPr0MIb7whe+0Py///f/2ma3MA83Amel7LPPPm2T/ulPf3qbVg/tlOvLf1+cLE7cLDaLq5GJFB/5yEe2lvTJJ5/c3PrWt24tey8qVr6yQWR3vvOdm4985CMrWUWKhx12WPPxj3+8ec1rXrMB2cG7B0444YQNXoIiq19l76d7xAspzlmW6nLIzZH/OWQOpb8vfJH1r3tS1K/zsIc9rG3OeBDe/va3b9TcVal9lRik6IEqSRHBIsYHPehBDVLUP1g65FvK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"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-09-04T11:21:57.000Z"><meta property="article:modified_time" content="2025-09-04T11:21:57.000Z"><link rel="icon" href="/favicon.ico"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="referrer" content="no-referrer"><title>线性表 | hupei's page</title><meta name="description" content="线性表 2.1 线性表的定义和基本操作 定义：线性表是具有相同数据类型的n (n≥0)个数据元素的有限序列，其中n为表长，当n =0时线性表是一个空表。 图片图片 2.2 线性表的顺序表示 2.2.1 顺序表的实现 线性表的顺序存储称为顺序表。特点是表中元素的逻辑顺序与其物理顺序相同，是一种随机存取的数据结构，通常用高级程序设计语言中的数组来描述线性表...">
    <link rel="preload" href="/assets/style-DzqZ4tuY.css" as="style"><link rel="stylesheet" href="/assets/style-DzqZ4tuY.css">
    <link rel="modulepreload" href="/assets/app-Bmvlbfib.js"><link rel="modulepreload" href="/assets/linear-list.html-CXcRRnU0.js">
    <link rel="prefetch" href="/assets/index.html-CMKaFI8A.js" as="script"><link rel="prefetch" href="/assets/home.html-CAEPfU2p.js" as="script"><link rel="prefetch" href="/assets/portfolio.html-CDYDbOFg.js" as="script"><link rel="prefetch" href="/assets/index.html-By8WO8jA.js" as="script"><link rel="prefetch" href="/assets/jdk.html-PKziPES7.js" as="script"><link rel="prefetch" href="/assets/maven.html-vxYy0Umf.js" as="script"><link rel="prefetch" href="/assets/mysql.html-Cgi47S2k.js" as="script"><link rel="prefetch" href="/assets/nodejs.html-DFby4Xjx.js" as="script"><link rel="prefetch" href="/assets/other.html-DUcrQexA.js" as="script"><link rel="prefetch" href="/assets/redis.html-BsyTi_35.js" as="script"><link rel="prefetch" href="/assets/index.html-BUUCnyDY.js" as="script"><link rel="prefetch" href="/assets/index.html-CtaAwgDg.js" as="script"><link rel="prefetch" href="/assets/http.html-c0luW303.js" as="script"><link rel="prefetch" href="/assets/introduction.html-C_rdJoDt.js" as="script"><link rel="prefetch" href="/assets/map.html-DjPhMB3Z.js" as="script"><link rel="prefetch" href="/assets/search-sort.html-CGnGphmV.js" as="script"><link rel="prefetch" href="/assets/stack-queue.html-iuwB2tpg.js" as="script"><link rel="prefetch" href="/assets/string.html-pG5aq2Cp.js" as="script"><link rel="prefetch" href="/assets/tree.html-Bc4Vcjfs.js" as="script"><link rel="prefetch" href="/assets/basic.html-BJboHZTW.js" as="script"><link rel="prefetch" href="/assets/basic.html-ybnz0rWO.js" as="script"><link rel="prefetch" href="/assets/exception-generics.html-lziAaLRZ.js" as="script"><link rel="prefetch" href="/assets/io-nio.html-fr6nu5t0.js" as="script"><link rel="prefetch" href="/assets/reflection-annotation.html-DvsOFO4a.js" as="script"><link rel="prefetch" href="/assets/constant-pool.html-DjWX8INw.js" as="script"><link rel="prefetch" href="/assets/hashmap.html-Bfbfc_n1.js" as="script"><link rel="prefetch" href="/assets/index.html-DmPCNiXI.js" as="script"><link rel="prefetch" href="/assets/404.html-DcnhTD3q.js" as="script"><link rel="prefetch" href="/assets/index.html-y_BzZJuj.js" as="script"><link rel="prefetch" href="/assets/index.html-Z95IPdMj.js" as="script"><link rel="prefetch" href="/assets/index.html-C9vTU_SK.js" as="script"><link rel="prefetch" href="/assets/index.html-zXDlxqD2.js" as="script"><link rel="prefetch" href="/assets/index.html-JE8x7jSH.js" as="script"><link rel="prefetch" href="/assets/index.html-D-y7MYWZ.js" as="script"><link rel="prefetch" href="/assets/index.html-CUjPB6_V.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-DXWKOczD.js" as="script"><link rel="prefetch" href="/assets/index-B-M8YVCw.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="带我回家"><img class="vp-nav-logo" src="/./logo.png" alt><!----><span class="vp-site-name hide-in-pad">hupei&#39;s page</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="主页" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" height="1em" sizing="height"></iconify-icon><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/portfolio.html" aria-label="档案主页" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:explosion" height="1em" sizing="height"></iconify-icon><!--]-->档案主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/home.html" aria-label="面试&amp;笔记" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:object-ungroup" height="1em" sizing="height"></iconify-icon><!--]-->面试&amp;笔记<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/env/" aria-label="环境配置" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:gear" height="1em" sizing="height"></iconify-icon><!--]-->环境配置<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!----><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-header"><iconify-icon class="vp-icon" icon="fa6-solid:mug-hot" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">JAVA</span><!----></p><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:cubes-stacked" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">JAVA基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:water" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">并发编程</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:smoking" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">JVM详解</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:database" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:computer" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">计算机基础</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:smoking" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">数据结构</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/cs/data-structure/introduction.html" aria-label="绪论" iconsizing="both"><!---->绪论<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/cs/data-structure/linear-list.html" aria-label="线性表" iconsizing="both"><!---->线性表<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs/data-structure/stack-queue.html" aria-label="栈与队列" iconsizing="both"><!---->栈与队列<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs/data-structure/string.html" aria-label="串" iconsizing="both"><!---->串<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs/data-structure/tree.html" aria-label="树" iconsizing="both"><!---->树<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs/data-structure/map.html" aria-label="图" iconsizing="both"><!---->图<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs/data-structure/search-sort.html" aria-label="查找与排序" iconsizing="both"><!---->查找与排序<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:smoking" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">计算机网络</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:smoking" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">操作系统</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->线性表</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://ishupei.github.io" target="_blank" rel="noopener noreferrer">HuPei</a></span><span property="author" content="HuPei"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025/9/4</span><meta property="datePublished" content="2025-09-04T11:21:57.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 31 分钟</span><meta property="timeRequired" content="PT31M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><h1 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表"><span>线性表</span></a></h1><h2 id="_2-1-线性表的定义和基本操作" tabindex="-1"><a class="header-anchor" href="#_2-1-线性表的定义和基本操作"><span><strong>2.1 线性表的定义和基本操作</strong></span></a></h2><p>定义：线性表是具有相同数据类型的n (n≥0)个数据元素的有限序列，其中n为表长，当n =0时线性表是一个空表。</p><figure><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUUAAACeCAYAAACl+hgFAAAgAElEQVR4Ae3dB7Q2VXU3cNZyfVmJK81oxEgiNgwosYJBxCAGLCAGUcDeRVQEFQsqWFBsKKLYCYqCoqAI9oKCIhJ7V1Swgb3GlhiTzLd+o/uu8847ZZ+XO3mfy33OWs8zZ878z96nzPxnnzpb/O///m+TcVkcWTXYjO5amVn9Wdxa0395K9NlPeWe0Zr7dK4y3Zz3Xlb3VDlt8T//8z8tiSmksV8WR0YNdkxnea1GZhabxdXmKSs3i6vVX5bbmH8O/WtFZk2ZzpGnsXrpXptD/xwyu+keO19k/VtIeMZlcVMsnNHVh5lD/xwya/I/l/6+8usLm0P/WpG5rKfcc19TTn332FDYHPfJkK6+8DH9S1LsK7GesLFC7MKz2CyO/BpsNz1D5zUys9gsriZPc8hcBP1D9dINnyP/c8jspnvsfJH1L0lxrOaKa3NU4hwyiyRPeufQv1ZkKpxsWrO4GpmTlVMA5tA/h8wiyZPeRda/JMXJ6vs9YI5KnENmMjstbA79a0WmAsimNYurkXl5rKfNnafV0r8caJkYYPJA+M3RMTyHzEhv5jiH/rUis6ZO58hTpn4CM4f+OWRGejPHRda/tBSTrxcVnXVZbBZHbw12tdNZo78mnVlsFleTzhrsXPovb/WUzU9N2ddis2kYq9MlKSZLcawQuyKy2Cxuc9wYi5SnucopKzeLW+/11L1nxs4XuUyXpDhWc8W1OSpxDplFkie9c+hfKzIVTjatWVyNzMnKKQBz6J9DZpHkSe8i61+S4mT1/R4wRyXOITOZnRY2h/61IlMBZNOaxdXIvDzW0+bO02rpXw60rNJAy69//evml7/8Ze+gzGc+85k23MNV/nQ2/+xnP2sOP/zw5ic/+ckG10ocf7dj+qlPfWrzrW99azSOeGeddVbzu9/9bgPc85///OanP/3pRjK7Osvzrv7yWunP4sTJYrO4Gpk12Ln0l+U25p9D/xwyx/LQvbbI+peWYvL1olK77hWveEVzwQUXNJ/73Oear33ta82+++7bPOMZz2he/vKXN3e7292aI488soFBep/61KdWor/vfe9rSQkRIqfjjz++edWrXtX6nX/3u99t7n//+zff//732zj/+Z//2ZKma34XX3xxc5Ob3KQ9RpgjOT/60Y9W9CDpbbbZpk3fb3/725XwnXbaqfnFL37REiVZGdeX/754WZy4WWwWVyOzi1XGfe6//uu/mqFr8B/84AebT3/60ytRM2n9zW9+07zrXe9q/vu//3sl3pgnIzPiZ7FZHLk12EjH1LFGZg12Sm9cH5O5JMUopYljXyE+7nGPawlnl112aT72sY81z3nOc1assnvd616Nm5/rPlQ3vOENm1NOOaV54xvf2Pt7/etf34Z/5StfaeOfd955zYknnriCve1tb9uSb1/8r371qys5ee1rX9sce+yxzSc+8Ynm4Q9/eEuyH/jAB5rtt9++Oeqoo1ryvu51r9v8+7//+0qcIU9f/vuwWZy4WWwWVyNTnSifcMr0ec97XvPCF76wefWrX90cccQRzUknndQ84QlPaJ7ylKcErPn5z3/elC8YL56dd955heCk1QuwJMqVyH/weBne+MY3bhBuuM9+9rPtiyrOy+Mc+Z9DZpnmKf8i61+SYqf2ugQWl/sqESmy0O50pzu1liJS9KB5kA4++ODWSnzWs57V7L777isPDXnXv/71m2984xvNoYce2mJYk/HTLL7RjW7UvPe97w3V7TH0ewj32muvRnP9P/7jP5pf/epXrR+B/uAHP9ggzq1udasVwnvoQx/akvO3v/3thqUo/p577tlccsklG8QZOgn9Q9cjPIuDz2KzuBqZ8r/33nu3L5vXve51ze1ud7vIQuMl9IIXvKA9j66HuOilovyjvhy9YF784he3YVoJRx99dEuwEUfLoMSTfYMb3KANixfg4x//+PalF3HK4xz5n0NmmeYp/yLrX5Ji07SExRJDIle5ylV63/J9lRik6IHSb4gU3/CGNzSnnnpq88UvfrElHJbbAQccsME9Eg8gmZrdHkoE9573vKd5xCMe0T6UXYKD1TS+733v2z7IL33pS5u3vvWtzTve8Y72yPr0MIb7whe+0Py///f/2ma3MA83Amel7LPPPm2T/ulPf3qbVg/tlOvLf1+cLE7cLDaLq5GJFB/5yEe2lvTJJ5/c3PrWt24tey8qVr6yQWR3vvOdm4985CMrWUWKhx12WPPxj3+8ec1rXrMB2cG7B0444YQNXoIiq19l76d7xAspzlmW6nLIzZH/OWQOpb8vfJH1r3tS1K/zsIc9rG3OeBDe/va3b9TcVal9lRik6IEqSRHBIsYHPehBDVLUP1g65FvK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" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_2-2-线性表的顺序表示" tabindex="-1"><a class="header-anchor" href="#_2-2-线性表的顺序表示"><span><strong>2.2 线性表的顺序表示</strong></span></a></h2><h3 id="_2-2-1-顺序表的实现" tabindex="-1"><a class="header-anchor" href="#_2-2-1-顺序表的实现"><span><strong>2.2.1 顺序表的实现</strong></span></a></h3><p>线性表的顺序存储称为顺序表。特点是表中元素的逻辑顺序与其物理顺序相同，是一种随机存取的数据结构，通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。</p><p>注意：线性表中元素的位序从1开始，而数组元素下标从0开始。</p><ol><li>顺序表的实现——<strong>静态分配</strong></li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;stdio.h&gt;</span></span>
<span class="line"><span>#define MaxSize 10      //定义最大长度 </span></span>
<span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    int data[MaxSize];  //用静态的“数组”存放数据元素 ElemType:int</span></span>
<span class="line"><span>    int Length;         //顺序表的当前长度</span></span>
<span class="line"><span>}SqList;                //顺序表的类型定义</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//基本操作——初始化一个顺序表</span></span>
<span class="line"><span>void InitList(SqList &amp;L){</span></span>
<span class="line"><span>    for(int j=0; j&lt;MaxSize; j++){</span></span>
<span class="line"><span>        L.data[j]=0;  //将数据元素设置为默认初始值0,内存中可能有遗留的“脏数据”</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    L.Length=0;        //顺序表初始长度为0</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//主函数</span></span>
<span class="line"><span>int main(){            </span></span>
<span class="line"><span>    SqList L;          //声明一个顺序表  在内存里分配存储顺序表L的空间</span></span>
<span class="line"><span>                       //包括MaxSize*sizeof(ElemType)和存储length的空间</span></span>
<span class="line"><span>    InitList(L);       //初始化这个顺序表</span></span>
<span class="line"><span>    //...</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>顺序表的实现——<strong>动态分配</strong></li></ol><p><code>malloc</code>函数:</p><p><code>L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize)</code></p><p>其中<code>(ElemType*)</code>可强制转换数据类型</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;stdlib.h&gt;       //malloc,free函数的头文件</span></span>
<span class="line"><span>#define InitSize 10       //默认的最大初始长度</span></span>
<span class="line"><span></span></span>
<span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    int *data;            //指示动态分配数组的指针</span></span>
<span class="line"><span>    int MaxSize;         //顺序表的最大容量</span></span>
<span class="line"><span>    int length;          //顺序表的当前长度</span></span>
<span class="line"><span>}SeqList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main(){</span></span>
<span class="line"><span>    SeqList L;</span></span>
<span class="line"><span>    InitList(L);</span></span>
<span class="line"><span>    //...其余操作</span></span>
<span class="line"><span>    IncreaseSize(L,5);</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>void InitList(SeqList &amp;L){</span></span>
<span class="line"><span>    L.data = (int*)malloc(InitSize*sizeof(int));  //用malloc函数申请一片连续的存储空间</span></span>
<span class="line"><span>    L.length = 0;         //此时尚未存入任何数据</span></span>
<span class="line"><span>    L.MaxSize = InitSize;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//增加动态数组的长度</span></span>
<span class="line"><span>void IncreaseSize(SeqList &amp;L, int len){</span></span>
<span class="line"><span>    int *p=L.data;</span></span>
<span class="line"><span>    L.data = (int*)malloc((L.MaxSize+len)*sizeof(int));</span></span>
<span class="line"><span>    for(int i=0; i&lt;L.length; i++){</span></span>
<span class="line"><span>        L.data[i] = p[i];       //将数据复制到新区域</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    L.MaxSize = L.MaxSize + len; //顺序表最大长度增加len</span></span>
<span class="line"><span>    free(p);                 //释放原来的内存空间</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-2-顺序表上基本操作的实现-插入和删除" tabindex="-1"><a class="header-anchor" href="#_2-2-2-顺序表上基本操作的实现-插入和删除"><span><strong>2.2.2 顺序表上基本操作的实现 (插入和删除)</strong></span></a></h3><ol><li>顺序表基本操作——插入</li></ol><p><strong>基于静态分配的代码实现</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define MaxSize 10      //定义最大长度 </span></span>
<span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    int data[MaxSize];  //用静态的“数组”存放数据元素</span></span>
<span class="line"><span>    int Length;         //顺序表的当前长度</span></span>
<span class="line"><span>}SqList;                //顺序表的类型定义</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//基本操作——在L的位序i处插入元素e</span></span>
<span class="line"><span>bool ListInsert(SqList &amp;L, int i, int e){ </span></span>
<span class="line"><span>    //判断i的范围是否有效</span></span>
<span class="line"><span>    if(i&lt;1||i&gt;L.length+1) </span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    if(L.length&gt;=MaxSize)  //当前存储空间已满，不能插入  </span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    for(int j=L.length; j&gt;=i; j--){    //将第i个元素及其之后的元素后移</span></span>
<span class="line"><span>        L.data[j]=L.data[j-1];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    L.data[i-1]=e;  //在位置i处放入e</span></span>
<span class="line"><span>    L.length++;      //长度加1</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main(){</span></span>
<span class="line"><span>    SqList L;          //声明一个顺序表</span></span>
<span class="line"><span>    InitList(L);       //初始化这个顺序表</span></span>
<span class="line"><span>    //...插入几个元素</span></span>
<span class="line"><span>    ListInsert(L,3,3);</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度分析</strong></p><ul><li><p>关注最深层循环语句——<code>L.data[j]=L.data[j-1]</code>的执行次数与问题规模n——<code>L.length</code>的关系;</p></li><li><p>最好情况：插入表尾，不需要移动元素，i=n+1，循环0次；最好时间复杂度 = O(1)</p></li><li><p>最坏情况：插入表头，需要将原有的n个元素全都向后移动，i=1，循环n次；最坏时间复杂度 = O(n)</p></li></ul><p>平均情况：假设新元素插入到任何一个位置的概率p(=1/n+1)相同</p><table><thead><tr><th style="text-align:left;"><strong>插入到第i个位置</strong></th><th style="text-align:left;"><strong>循环次数</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>1</strong></td><td style="text-align:left;"><strong>n</strong></td></tr><tr><td style="text-align:left;"><strong>2</strong></td><td style="text-align:left;"><strong>n-1</strong></td></tr><tr><td style="text-align:left;"><strong>3</strong></td><td style="text-align:left;"><strong>n-2</strong></td></tr><tr><td style="text-align:left;"><strong>…</strong></td><td style="text-align:left;"><strong>…</strong></td></tr><tr><td style="text-align:left;"><strong>n+1</strong></td><td style="text-align:left;"><strong>0</strong></td></tr></tbody></table><p><strong>平均循环次数</strong> = np + (n-1)p + (n-2)p + … + 1×p = [ n(n+1)/2 ]×[ 1/(n+1) ] = n/2</p><p><strong>平均时间复杂度</strong> = O(n)</p><ol><li>顺序表基本操作——删除</li></ol><p><code>ListDelete(&amp;L,i,e)</code>:删除表L中的第i个位置的元素，并用e返回删除元素的值</p><p><strong>基于静态分配的代码实现</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define MaxSize 10      //定义最大长度 </span></span>
<span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    int data[MaxSize];       //用静态的“数组”存放数据元素 </span></span>
<span class="line"><span>    int Length;             //顺序表的当前长度</span></span>
<span class="line"><span>}SqList;                   //顺序表的类型定义</span></span>
<span class="line"><span></span></span>
<span class="line"><span>bool ListDelete(SqList &amp;L, int i, int &amp;e){       // e用引用型参数 </span></span>
<span class="line"><span>    if(i&lt;1||i&gt;L.length)           //判断i的范围是否有效</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    e = L.data[i-1];         //将被删除的元素赋值给e</span></span>
<span class="line"><span>    for(int j=i; j&lt;L.length; j++){        //将第i个后的元素前移</span></span>
<span class="line"><span>        L.data[j-1]=L.data[j];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    L.length--;        //长度减1</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main(){</span></span>
<span class="line"><span>    SqList L;            //声明一个顺序表</span></span>
<span class="line"><span>    InitList(L);         //初始化这个顺序表</span></span>
<span class="line"><span>    //省略代码...插入几个元素</span></span>
<span class="line"><span>    int e = -1;          //用变量e把删除的元素“带回来”</span></span>
<span class="line"><span>    if(ListDelete(L,3,e))</span></span>
<span class="line"><span>        printf(&quot;已删除第三个元素，删除元素值=%d\n&quot;,e);</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        printf(&quot;位序i不合法，删除失败\n&quot;);</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度分析</strong></p><ul><li><p>关注最深层循环语句——<code>L.data[j-1]=L.data[j]</code>的执行次数与问题规模n——<code>L.length</code>的关系;</p></li><li><p>最好情况：删除表尾元素，不需要移动元素，i=n，循环0次；最好时间复杂度 = O(1);</p></li><li><p>最坏情况：删除表头元素，需要将后续的n-1个元素全都向前移动，i=1，循环n-1次；最坏时间复杂度 = O(n);</p></li></ul><p>平均情况：假设删除任何一个元素(1,2,3,…,length)的概率相同 p=1/n</p><table><thead><tr><th style="text-align:left;"><strong>删除第i个元素</strong></th><th style="text-align:left;"><strong>循环次数</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>1</strong></td><td style="text-align:left;"><strong>n-1</strong></td></tr><tr><td style="text-align:left;"><strong>2</strong></td><td style="text-align:left;"><strong>n-2</strong></td></tr><tr><td style="text-align:left;"><strong>3</strong></td><td style="text-align:left;"><strong>n-3</strong></td></tr><tr><td style="text-align:left;"><strong>…</strong></td><td style="text-align:left;"><strong>…</strong></td></tr><tr><td style="text-align:left;"><strong>n</strong></td><td style="text-align:left;"><strong>0</strong></td></tr></tbody></table><p><strong>平均循环次数</strong> = (n-1)p + (n-2)p + … + 1×p = [ n(n-1)/2 ]×[ 1/(n) ] = n-1/2</p><p><strong>平均时间复杂度</strong> = O(n)</p><ol><li>顺序表基本操作——<strong>按位查找(顺序表)</strong></li></ol><p><code>GetElem(L,i)</code> : 按位查找操作——获取表L中第i个位置元素的值</p><p><strong>基于静态分配的代码实现</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define MaxSize 10            //定义最大长度 </span></span>
<span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    ElemType data[MaxSize];  //用静态的“数组”存放数据元素 </span></span>
<span class="line"><span>    int Length;              //顺序表的当前长度</span></span>
<span class="line"><span>}SqList;                     //顺序表的类型定义</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ElemType GetElem(SqList L, int i){</span></span>
<span class="line"><span>    // ...判断i的值是否合法</span></span>
<span class="line"><span>    return L.data[i-1];      //注意是i-1</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>基于动态分配的代码实现</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define InitSize 10  //顺序表的初始长度</span></span>
<span class="line"><span></span></span>
<span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    ElemType *data;  //指示动态分配数组的指针</span></span>
<span class="line"><span>    int MaxSize;     //顺序表的最大容量</span></span>
<span class="line"><span>    int length;      //顺序表的当前长度</span></span>
<span class="line"><span>}SeqList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ElemType GetElem(SqList L, int i){</span></span>
<span class="line"><span>    // ...判断i的值是否合法</span></span>
<span class="line"><span>    return L.data[i-1];       //就算是指针也能用数组下标哦!</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度分析</strong><br><strong>O(1)</strong></p><p>由于顺序表的各个数据元素在内存中连续存放，因此可以根据<strong>起始地址</strong>和<strong>数据元素大小</strong>立即找到第i个元素———“随机存取”特性；</p><ol><li>顺序表基本操作——<strong>按值查找</strong></li></ol><p><code>LocateElem(L, e)</code>: 按值查找操作，在表L中查找具有给定关键字值的元素；</p><p><strong>基于动态分配的代码实现</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define InitSize 10            //定义最大长度 </span></span>
<span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    ElemTyp *data;            //用静态的“数组”存放数据元素</span></span>
<span class="line"><span>    int MaxSize;             //顺序表的最大容量</span></span>
<span class="line"><span>    int Length;              //顺序表的当前长度</span></span>
<span class="line"><span>}SqList;                     //顺序表的类型定义（动态分配方式）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span>
<span class="line"><span>int LocateElem(SqList L, ElemType e){</span></span>
<span class="line"><span>    for(int i=0; i&lt;L.length；i++)</span></span>
<span class="line"><span>        if(L.data[i] == e)     //基本数据类型可以直接用运算符&#39;==&#39;比较</span></span>
<span class="line"><span>            return i+1;       //数组下标为i的元素值等于e，返回其位序i+1</span></span>
<span class="line"><span>    return 0;                 //退出循环，说明查找失败</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Q:</strong> 如果顺序表里存放的是结构类型的数据元素，可不可以用 <code>==</code> 进行比较？<br><strong>A:</strong> 不能！结构类型的比较，需要依次对比各个分量来判断两个结构体是否相等；</p><p>例： hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    int num;</span></span>
<span class="line"><span>    int people;</span></span>
<span class="line"><span>}Customer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void test(){</span></span>
<span class="line"><span>    Customer a;</span></span>
<span class="line"><span>    a.num = 1; a.people = 1;</span></span>
<span class="line"><span>    Customer b;</span></span>
<span class="line"><span>    b.num = 1; b.people = 1;</span></span>
<span class="line"><span>    //...</span></span>
<span class="line"><span>    if (a.num == b.num &amp;&amp; a.people == b.people){</span></span>
<span class="line"><span>        printf(&quot;相等&quot;);</span></span>
<span class="line"><span>    }else{</span></span>
<span class="line"><span>        printf(&quot;不相等&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>bool isCustomerEqual(Customer a,Customer b){</span></span>
<span class="line"><span>      if(a.num == b.num &amp;&amp; a.people == b.people)</span></span>
<span class="line"><span>      return true;</span></span>
<span class="line"><span>      else</span></span>
<span class="line"><span>      return false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度分析</strong></p><ul><li><p>最深处循环语句: <code>if(L.data[i] == e)</code> 与问题规模n=<code>L.length(表长)</code>的关系；</p></li><li><p>最好情况：查找目标元素在表头，循环1次，最好时间复杂度=O(1)</p></li><li><p>最坏情况：查找目标元素在表尾，循环n次，最好时间复杂度=O(n)</p></li><li><p>平均情况：假设目标元素出现在任何一个位置的概率相同，p=1/n</p></li></ul><table><thead><tr><th style="text-align:left;"><strong>目标元素所在位置i</strong></th><th style="text-align:left;"><strong>循环次数</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>1</strong></td><td style="text-align:left;"><strong>1</strong></td></tr><tr><td style="text-align:left;"><strong>2</strong></td><td style="text-align:left;"><strong>2</strong></td></tr><tr><td style="text-align:left;"><strong>3</strong></td><td style="text-align:left;"><strong>3</strong></td></tr><tr><td style="text-align:left;"><strong>…</strong></td><td style="text-align:left;"><strong>…</strong></td></tr><tr><td style="text-align:left;"><strong>n</strong></td><td style="text-align:left;"><strong>n</strong></td></tr></tbody></table><p><strong>平均循环次数</strong> = 1×1/n + 2×1/n +…+ n×1/n = [ n(n+1)/2 ] × 1/n = (n+1)/2</p><p><strong>平均时间复杂度</strong> = O(n)</p><h2 id="_2-3-线性表的链式表示" tabindex="-1"><a class="header-anchor" href="#_2-3-线性表的链式表示"><span><strong>2.3 线性表的链式表示</strong></span></a></h2><h3 id="_2-3-1-单链表的定义" tabindex="-1"><a class="header-anchor" href="#_2-3-1-单链表的定义"><span><strong>2.3.1 单链表的定义</strong></span></a></h3><ol><li>何为单链表？</li></ol><ul><li><p>链式存储</p></li><li><p>每个结点存储：数据元素自身信息 &amp; 指向下一个结点(后继)的指针</p></li><li><p>优点：不要求大片连续空间，改变容量方便</p></li><li><p>缺点：不可随机存取，要耗费一定空间存放指针</p></li></ul><ol><li>代码定义单链表</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>struct LNode{            //定义单链表节点类型  LNode:结点</span></span>
<span class="line"><span>    ElemType data;       //每个结点存放一个数据元素 data:数据域</span></span>
<span class="line"><span>    struct LNode *next;  //指针指向下一个结点 next:指针域</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>增加一个新的结点：在内存中申请一个结点所需的空间，并用指针p指向这个结点</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>struct LNode* p = (struct LNode*) malloc(sizeof(struct LNode))；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果每次都要写struct很麻烦，所以可以利用typedef关键字——数据类型重命名：<code>type&lt;数据类型&gt;&lt;别名&gt;</code><br> Eg:</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef int zhengshu;</span></span>
<span class="line"><span>typedef int *zhengshuzhizhen;  //指向int型的指针</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面操作可以化简为:</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode LNode;</span></span>
<span class="line"><span>LNode* p = (LNode*)malloc(sizeof(LNode));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>最简洁代码实现:</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode{            //定义单链表结点类型</span></span>
<span class="line"><span>    ElemType data;               //每个节点存放一个数据元素</span></span>
<span class="line"><span>    struct LNode *next;          //指针指向下一个节点</span></span>
<span class="line"><span>}LNode, *LinkList;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码等同于：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>struct LNode{                   //定义单链表结点类型</span></span>
<span class="line"><span>    ElemType data;              //每个节点存放一个数据元素</span></span>
<span class="line"><span>    struct LNode *next;         //指针指向下一个节点</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>typedef struct LNode LNode; //重命名</span></span>
<span class="line"><span>typedef struct LNode *LinkList;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LNode *L;    // 声明一个指向单链表第一个结点的指针，强调这是结点</span></span>
<span class="line"><span>LinkList L;  // 声明一个指向单链表第一个结点的指针，强调这是链表</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>单链表两种实现方法</li></ol><ul><li>不带头结点的单链表</li></ul><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode{              //定义单链表结点类型</span></span>
<span class="line"><span>    ElemType data;                 //每个节点存放一个数据元素</span></span>
<span class="line"><span>    struct LNode *next;            //指针指向下一个节点</span></span>
<span class="line"><span>}LNode, *LinkList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//初始化一个空的单链表</span></span>
<span class="line"><span>bool InitList(LinkList &amp;L){      //注意用引用 &amp;，要&#39;带回来&#39;</span></span>
<span class="line"><span>    L = NULL;                   //空表，暂时还没有任何结点</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void test(){</span></span>
<span class="line"><span>    LinkList L;            //声明一个指向单链表的指针: 头指针</span></span>
<span class="line"><span>    InitList(L);          //初始化一个空表</span></span>
<span class="line"><span>    //...后续代码...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//判断单链表是否为空</span></span>
<span class="line"><span>bool Empty(LinkList L){</span></span>
<span class="line"><span>    if (L == NULL)</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>//或者：等价于判断单链表是否为空</span></span>
<span class="line"><span>bool Empty(LinkList L){</span></span>
<span class="line"><span>   return (L == NULL);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>带头结点的单链表</li></ul><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode{              //定义单链表结点类型</span></span>
<span class="line"><span>    ElemType data;                 //每个节点存放一个数据元素</span></span>
<span class="line"><span>    struct LNode *next;            //指针指向下一个节点</span></span>
<span class="line"><span>}LNode, *LinkList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//初始化一个单链表（带头结点）</span></span>
<span class="line"><span>bool InitList(LinkList &amp;L){  </span></span>
<span class="line"><span>    L = (LNode*)malloc(sizeof(LNode));     //分配一个头结点（不存储数据）</span></span>
<span class="line"><span>    if (L == NULL)                //内存不足，分配失败</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    L -&gt; next = NULL;           //头结点之后暂时还没有结点</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void test(){</span></span>
<span class="line"><span>    LinkList L;            //声明一个指向单链表的指针: 头指针</span></span>
<span class="line"><span>    InitList(L);           //初始化一个空表</span></span>
<span class="line"><span>    //...后续代码</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//判断单链表是否为空（带头结点）</span></span>
<span class="line"><span>bool Empty(LinkList L){</span></span>
<span class="line"><span>    if (L-&gt;next == NULL)</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>不带头结点 V.S. 带头结点</strong></p><ul><li><p>不带头结点：写代码麻烦！对第一个数据节点和后续数据节点的处理需要用不同的代码逻辑，对空表和非空表的处理也需要用不同的代码逻辑; 头指针指向的结点用于存放实际数据;</p></li><li><p>带头结点：头指针指向的头结点不存放实际数据,头结点指向的下一个结点才存放实际数据;</p></li><li><p>单链表设置头结点的目的是方便运算的实现。</p></li></ul><h3 id="_2-3-2-单链表上基本操作的实现" tabindex="-1"><a class="header-anchor" href="#_2-3-2-单链表上基本操作的实现"><span><strong>2.3.2 单链表上基本操作的实现</strong></span></a></h3><p><strong>1. 单链表的插入</strong></p><ul><li><strong>按位序插入 (带头结点)</strong></li></ul><p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后；其中头结点可以看作第0个结点，故i=1时也适用。</p><p>代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode{</span></span>
<span class="line"><span>    ElemType data;</span></span>
<span class="line"><span>    struct LNode *next;</span></span>
<span class="line"><span>}LNode, *LinkList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//在第i个位置插入元素e（带头结点）</span></span>
<span class="line"><span>bool ListInsert(LinkList &amp;L, int i, ElemType e){  </span></span>
<span class="line"><span>    //判断i的合法性, i是位序号(从1开始)</span></span>
<span class="line"><span>    if(i&lt;1)</span></span>
<span class="line"><span>        return false; </span></span>
<span class="line"><span>    LNode *p;           //指针p指向当前扫描到的结点 </span></span>
<span class="line"><span>    int j = 0;          //当前p指向的是第几个结点</span></span>
<span class="line"><span>    p = L;              //L指向头结点，头结点是第0个结点（不存数据）</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    //循环找到第i-1个结点</span></span>
<span class="line"><span>    while(p!=NULL &amp;&amp; j&lt;i-1){     //如果i&gt;lengh, p最后会等于NULL</span></span>
<span class="line"><span>        p = p-&gt;next;             //p指向下一个结点</span></span>
<span class="line"><span>        j++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    if (p==NULL)                 //i值不合法</span></span>
<span class="line"><span>        return false;    </span></span>
<span class="line"><span>    //在第i-1个结点后插入新结点</span></span>
<span class="line"><span>    LNode *s = (LNode *)malloc(sizeof(LNode)); //申请一个结点</span></span>
<span class="line"><span>    s-&gt;data = e;</span></span>
<span class="line"><span>    s-&gt;next = p-&gt;next;</span></span>
<span class="line"><span>    p-&gt;next = s;                 //将结点s连到p后,后两步千万不能颠倒qwq</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度分析</p><blockquote><p>最好情况：插入第1个位置 O(1)<br> 最坏情况：插入表尾 O(n)<br> 平均时间复杂度 = O(n)</p></blockquote><ul><li><strong>按位序插入 (不带头结点)</strong></li></ul><p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后; 因为不带头结点，所以不存在“第0个”结点，因此！i=1 时，需要特殊处理——插入(删除)第1个元素时，需要更改头指针L;</p><p>代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode{</span></span>
<span class="line"><span>    ElemType data;</span></span>
<span class="line"><span>    struct LNode *next;</span></span>
<span class="line"><span>}LNode, *LinkList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>bool ListInsert(LinkList &amp;L, int i, ElemType e){</span></span>
<span class="line"><span>    if(i&lt;1)</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    if(i==1){          //插入到第1个位置时的操作有所不同！</span></span>
<span class="line"><span>        LNode *s = (LNode *)malloc(sizeof(LNode));</span></span>
<span class="line"><span>        s-&gt;data =e;</span></span>
<span class="line"><span>        s-&gt;next =L;</span></span>
<span class="line"><span>        L=s;          //头指针指向新结点</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //i&gt;1的情况与带头结点一样！唯一区别是j的初始值为1</span></span>
<span class="line"><span>    LNode *p;       //指针p指向当前扫描到的结点 </span></span>
<span class="line"><span>    int j=1;        //当前p指向的是第几个结点</span></span>
<span class="line"><span>    p = L;          //L指向头结点，头结点是第0个结点（不存数据）</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>     //循环找到第i-1个结点</span></span>
<span class="line"><span>    while(p!=NULL &amp;&amp; j&lt;i-1){     //如果i&gt;lengh, p最后会等于NULL</span></span>
<span class="line"><span>        p = p-&gt;next;             //p指向下一个结点</span></span>
<span class="line"><span>        j++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    if (p==NULL)                 //i值不合法</span></span>
<span class="line"><span>        return false;  </span></span>
<span class="line"><span>    //在第i-1个结点后插入新结点</span></span>
<span class="line"><span>    LNode *s = (LNode *)malloc(sizeof(LNode)); //申请一个结点</span></span>
<span class="line"><span>    s-&gt;data = e;</span></span>
<span class="line"><span>    s-&gt;next = p-&gt;next;</span></span>
<span class="line"><span>    p-&gt;next = s;          </span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除非特别声明，否则之后的代码都默认为带头结点哦，做题注意审题</p><ul><li><strong>指定结点的后插操作</strong></li></ul><p><code>InsertNextNode(LNode *p, ElemType e)</code>: 给定一个结点p，在其之后插入元素e; 根据单链表的链接指针只能往后查找，故给定一个结点p，那么p之后的结点我们都可知，但是p结点之前的结点无法得知;</p><p>代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode{</span></span>
<span class="line"><span>    ElemType data;</span></span>
<span class="line"><span>    struct LNode *next;</span></span>
<span class="line"><span>}LNode, *LinkList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//后插操作：在p结点之后插入元素e</span></span>
<span class="line"><span>bool InsertNextNode(LNode *p, ElemType e){     </span></span>
<span class="line"><span>    if(p==NULL)</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    LNode *s = (LNode *)malloc(sizeof(LNode));</span></span>
<span class="line"><span>    //某些情况下有可能分配失败，比如内存不足</span></span>
<span class="line"><span>    if(s==NULL)</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    s-&gt;data = e;          //用结点s保存数据元素e </span></span>
<span class="line"><span>    s-&gt;next = p-&gt;next;</span></span>
<span class="line"><span>    p-&gt;next = s;          //将结点s连到p之后</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}                         //平均时间复杂度 = O(1)</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>//有了后插操作，那么在第i个位置上插入指定元素e的代码可以改成：</span></span>
<span class="line"><span>bool ListInsert(LinkList &amp;L, int i, ElemType e){  </span></span>
<span class="line"><span>    if(i&lt;1)</span></span>
<span class="line"><span>        return False;   </span></span>
<span class="line"><span>    LNode *p;       //指针p指向当前扫描到的结点 </span></span>
<span class="line"><span>    int j=0;        //当前p指向的是第几个结点</span></span>
<span class="line"><span>    p = L;          //L指向头结点，头结点是第0个结点（不存数据）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //循环找到第i-1个结点</span></span>
<span class="line"><span>    while(p!=NULL &amp;&amp; j&lt;i-1){     //如果i&gt;lengh, p最后会等于NULL</span></span>
<span class="line"><span>        p = p-&gt;next;             //p指向下一个结点</span></span>
<span class="line"><span>        j++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return InsertNextNode(p, e)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>指定结点的前插操作</strong></li></ul><p><strong>Q:</strong> 如何找到p结点的前驱节点？</p><p><strong>A:</strong> 传入头指针L！就可以知道整个链表的信息了！</p><p><code>InsertPriorNode(LinkList L, LNode *p, ElemType e)</code>：循环查找p的前驱q，再对q进行后插操作，时间复杂度为O(n);</p><p><strong>Q:</strong> 那如果不传入头指针L呢？</p><p>不传入头指针L的代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//前插操作：在p结点之前插入元素e</span></span>
<span class="line"><span>bool InsertPriorNode(LNode *p, ElenType e){</span></span>
<span class="line"><span>    if(p==NULL)</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    LNode *s = (LNode *)malloc(sizeof(LNode));</span></span>
<span class="line"><span>    if(s==NULL)           //内存分配失败</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //重点来了！</span></span>
<span class="line"><span>    s-&gt;next = p-&gt;next;</span></span>
<span class="line"><span>    p-&gt;next = s;             //新结点s连到p之后</span></span>
<span class="line"><span>    s-&gt;data = p-&gt;data;       //将p中元素复制到s</span></span>
<span class="line"><span>    p-&gt;data = e;             //p中元素覆盖为e</span></span>
<span class="line"><span>    return true；</span></span>
<span class="line"><span>}        //时间复杂度为O(1)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>王道书版本代码 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bool InsertPriorNode(LNode *p, LNode *s){</span></span>
<span class="line"><span>    if(p==NULL || S==NULL)</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    s-&gt;next = p-&gt;next;</span></span>
<span class="line"><span>    p-&gt;next = s;                    //s连接到p</span></span>
<span class="line"><span>    ELemType temp = p-&gt;data;        //交换数据域部分</span></span>
<span class="line"><span>    p-&gt;data = s-&gt;data;</span></span>
<span class="line"><span>    s-&gt;data = temp;</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. 单链表的删除</strong></p><ul><li><strong>按位序删除(带头结点)</strong></li></ul><p><code>ListDelete(&amp;L, i, &amp;e)</code>: 删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值;头结点视为“第0个”结点；</p><p><em>思路：找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点；</em></p><p>代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode{</span></span>
<span class="line"><span>    ElemType data;</span></span>
<span class="line"><span>    struct LNode *next;</span></span>
<span class="line"><span>}LNode, *LinkList;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>bool ListDelete(LinkList &amp;L, int i, ElenType &amp;e){</span></span>
<span class="line"><span>    if(i&lt;1)</span></span>
<span class="line"><span>       return false;</span></span>
<span class="line"><span>    LNode *p;           //指针p指向当前扫描到的结点 </span></span>
<span class="line"><span>    int j=0;            //当前p指向的是第几个结点</span></span>
<span class="line"><span>    p = L;              //L指向头结点，头结点是第0个结点（不存数据）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //循环找到第i-1个结点</span></span>
<span class="line"><span>    while(p!=NULL &amp;&amp; j&lt;i-1){     //如果i&gt;lengh, p最后会等于NULL</span></span>
<span class="line"><span>        p = p-&gt;next;             //p指向下一个结点</span></span>
<span class="line"><span>        j++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    if(p==NULL)                 //i值不合法</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    if(p-&gt;next == NULL)         //第i-1个结点之后已无其他结点</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    LNode *q = p-&gt;next;         //令q指向被删除的结点</span></span>
<span class="line"><span>    e = q-&gt;data;                //用e返回被删除元素的值</span></span>
<span class="line"><span>    p-&gt;next = q-&gt;next;          //将*q结点从链中“断开”</span></span>
<span class="line"><span>    free(q)                     //释放结点的存储空间</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度分析：</p><blockquote><p>最坏，平均时间复杂度：O(n)<br> 最好时间复杂度：删除第一个结点 O(1)</p></blockquote><ul><li><strong>指定结点的删除</strong></li></ul><p>删除结点p，需要修改其前驱结点的next指针(两个方法)；</p><p>&quot;偷天换日&quot;代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bool DeleteNode(LNode *p){</span></span>
<span class="line"><span>    if(p==NULL)</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    LNode *q = p-&gt;next;            //令q指向*p的后继结点</span></span>
<span class="line"><span>    p-&gt;data = p-&gt;next-&gt;data;       //让p和后继结点交换数据域</span></span>
<span class="line"><span>    p-&gt;next = q-&gt;next;             //将*q结点从链中“断开”</span></span>
<span class="line"><span>    free(q);</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}                         //时间复杂度 = O(1)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>但是</strong> 如果p是最后一个结点，那么<code>p-&gt;next = q-&gt;next</code> and <code>p-&gt;data = p-&gt;next-&gt;data</code> 就会出错，只能从表头开始依次寻找o的前驱，时间复杂度为O(n); 这就是单链表的<strong>局限性</strong>——无法逆向检索。<br><strong>3. 单链表的查找</strong></p><p><em>探讨带头结点！</em></p><ul><li><strong>按位查找</strong></li></ul><p><code>GetElem(L, i):</code> 按位查找操作，获取表L中第i个位置的元素的值;</p><p>代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LNode * GetElem(LinkList L, int i){</span></span>
<span class="line"><span>    if(i&lt;0)</span></span>
<span class="line"><span>         return NULL;</span></span>
<span class="line"><span>    LNode *p;                   //指针p指向当前扫描到的结点</span></span>
<span class="line"><span>    int j=0;                    //当前p指向的是第几个结点</span></span>
<span class="line"><span>    p = L;                      //L指向头结点,头结点是第0个结点(不存数据)</span></span>
<span class="line"><span>    while(p!=NULL &amp;&amp; j&lt;i){      //循环找到第i个结点</span></span>
<span class="line"><span>        p = p-&gt;next;</span></span>
<span class="line"><span>        j++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return p;               //返回p指针指向的值</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>平均时间复杂度</strong> = O(n)<br> 王道书版本代码 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LNode * GetElem(LinkList L, int i){</span></span>
<span class="line"><span>    int j=1;                      //从第一个结点开始</span></span>
<span class="line"><span>    LNode *p = L-&gt;next;           //p先指向第一个结点</span></span>
<span class="line"><span>    if(i==0)</span></span>
<span class="line"><span>         return L;</span></span>
<span class="line"><span>    if(i&lt;1)  </span></span>
<span class="line"><span>         return NULL;</span></span>
<span class="line"><span>    while(p!=NULL &amp;&amp; j&lt;i){        //循环找到第i个结点</span></span>
<span class="line"><span>        p = p-&gt;next;</span></span>
<span class="line"><span>        j++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return p;                 //返回p指针指向的值</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么上一节的按位插入和按位删除就可以封装了！</p><ul><li><strong>按值查找</strong></li></ul><p><code>LocateElem(L, e):</code>按值查找操作，在表L中查找具有给定关键字值的元素;</p><p>代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//按值查找，找到数据域==e的结点</span></span>
<span class="line"><span>LNode * LocateElem(LinkList L, ElemType e){</span></span>
<span class="line"><span>    LNode *p = L-&gt;next;            //p指向第一个结点</span></span>
<span class="line"><span>    //从第一个结点开始查找数据域为e的结点</span></span>
<span class="line"><span>    while(p!=NULL &amp;&amp; p-&gt;data != e){</span></span>
<span class="line"><span>        p = p-&gt;next;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return p;           //找到后返回该结点指针，否则返回NULL</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意当ElemType是结构体时的操作</strong><br><strong>4. 求单链表的长度</strong></p><p><code>Length(LinkList L)</code></p><p>代码实现 (带头结点)</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//求表的长度</span></span>
<span class="line"><span>int Length(LinkList L){</span></span>
<span class="line"><span>    int len=0;         //统计表长</span></span>
<span class="line"><span>    LNode *p = L;</span></span>
<span class="line"><span>    while(p-&gt;next != NULL){</span></span>
<span class="line"><span>        p = p-&gt;next;</span></span>
<span class="line"><span>        len++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return len;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>平均时间复杂度=</strong> O(n)<br><strong>5. 单链表的建立</strong></p><p><strong>思路：</strong> 初始化一个单链表 -&gt; 每取一个数据元素，插入到表尾/表头</p><p><strong>核心：</strong> 初始化操作 and 指定结点的后插操作</p><p><em>探讨带头结点！</em></p><ul><li>尾插法建立单链表</li></ul><p><strong>解决方法</strong>：设置一个表尾指针r，对r这个结点进行后插操作<code>InsertNextNode()</code></p><p>最终代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LinkList List_TailInsert(LinkList &amp;L){       //正向建立单链表</span></span>
<span class="line"><span>    int x;                                   //设ElemType为整型int</span></span>
<span class="line"><span>    L = (LinkList)malloc(sizeof(LNode));     //建立头结点(初始化空表)</span></span>
<span class="line"><span>    LNode *s, *r = L;                        //r为表尾指针</span></span>
<span class="line"><span>    scanf(&quot;%d&quot;, &amp;x);                         //输入要插入的结点的值</span></span>
<span class="line"><span>    while(x!=9999){                          //输入9999表结束</span></span>
<span class="line"><span>        s = (LNode *)malloc(sizeof(LNode));</span></span>
<span class="line"><span>        s-&gt;data = x;</span></span>
<span class="line"><span>        r-&gt;next = s;</span></span>
<span class="line"><span>        r = s;                             //r指针指向新的表尾结点</span></span>
<span class="line"><span>        scanf(&quot;%d&quot;, &amp;x);   </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    r-&gt;next = NULL;                          //尾结点指针置空</span></span>
<span class="line"><span>    return L;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>平均时间复杂度</strong>：O(n)</p><ul><li>头插法建立单链表</li></ul><p>对头结点进行后插操作<code>InsertNextNode()</code></p><p>最终代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LinkList List_HeadInsert(LinkList &amp;L){       //逆向建立单链表</span></span>
<span class="line"><span>    LNode *s; </span></span>
<span class="line"><span>    int x;</span></span>
<span class="line"><span>    L = (LinkList)malloc(sizeof(LNode));     //建立头结点</span></span>
<span class="line"><span>    L-&gt;next = NULL;                          //初始为空链表,这步不能少！</span></span>
<span class="line"><span>    scanf(&quot;%d&quot;, &amp;x);                         //输入要插入的结点的值</span></span>
<span class="line"><span>    while(x!=9999){                          //输入9999表结束</span></span>
<span class="line"><span>        s =(LNode*)malloc(sizeof(LNode));    //创建新结点</span></span>
<span class="line"><span>        s-&gt;data = x;</span></span>
<span class="line"><span>        s-&gt;next = L-&gt;next;</span></span>
<span class="line"><span>        L-&gt;next = s;                         //将新结点插入表中，L为头指针</span></span>
<span class="line"><span>        scanf(&quot;%d&quot;, &amp;x);   </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return L;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>PS: 只要是初始化单链表，都先将头指针指向NULL —</strong><code>L-&gt;next = NULL</code>;</p><h2 id="重要应用-链表的逆置" tabindex="-1"><a class="header-anchor" href="#重要应用-链表的逆置"><span><strong>重要应用：链表的逆置</strong></span></a></h2><ul><li>算法思想：逆置链表初始为空，原表中结点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空；</li></ul><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LNode *Inverse(LNode *L)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	LNode *p, *q;</span></span>
<span class="line"><span>	p = L-&gt;next;     //p指针指向第一个结点</span></span>
<span class="line"><span>	L-&gt;next = NULL;  //头结点指向NULL</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	while (p != NULL){</span></span>
<span class="line"><span>		q = p;</span></span>
<span class="line"><span>		p = p-&gt;next;</span></span>
<span class="line"><span>		q-&gt;next = L-&gt;next;  </span></span>
<span class="line"><span>		L-&gt;next = q;</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>	return L;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-3-双链表" tabindex="-1"><a class="header-anchor" href="#_2-3-3-双链表"><span><strong>2.3.3 双链表</strong></span></a></h3><ol><li>双链表的初始化 (带头结点) hedui</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct DNode{                //定义双链表结点类型</span></span>
<span class="line"><span>    ElemType data;                   //数据域</span></span>
<span class="line"><span>    struct DNode *prior, *next;      //前驱和后继指针</span></span>
<span class="line"><span>}DNode, *DLinklist;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//初始化双链表</span></span>
<span class="line"><span>bool InitDLinkList(Dlinklist &amp;L){</span></span>
<span class="line"><span>    L = (DNode *)malloc(sizeof(DNode));      //分配一个头结点</span></span>
<span class="line"><span>    if(L==NULL)                              //内存不足，分配失败</span></span>
<span class="line"><span>        return false; </span></span>
<span class="line"><span>    L-&gt;prior = NULL;       //头结点的prior指针永远指向NULL</span></span>
<span class="line"><span>    L-&gt;next = NULL;        //头结点之后暂时还没有结点</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void testDLinkList(){     </span></span>
<span class="line"><span>    DLinklist L;         //初始化双链表，定义指向头结点的指针L</span></span>
<span class="line"><span>    InitDLinkList(L);    //申请一片空间用于存放头结点，指针L指向这个头结点</span></span>
<span class="line"><span>    //...后续代码</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//判断双链表是否为空</span></span>
<span class="line"><span>bool Empty(DLinklist L){</span></span>
<span class="line"><span>    if(L-&gt;next == NULL)        //判断头结点的next指针是否为空</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与单链表中一样，<code>DLinklist</code> 强调链表， <code>DNode *</code>强调结点，二者本质上等价;</p><ol><li>双链表的插入操作</li></ol><ul><li>后插操作</li></ul><p><code>InsertNextDNode(p, s)</code>: 在p结点后插入s结点</p><p>代码实现:</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bool InsertNextDNode(DNode *p, DNode *s){     //在p结点后插入s结点</span></span>
<span class="line"><span>    if(p==NULL || s==NULL) //非法参数</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    s-&gt;next = p-&gt;next;</span></span>
<span class="line"><span>    if (p-&gt;next != NULL)   //p不是最后一个结点=p有后继结点  </span></span>
<span class="line"><span>        p-&gt;next-&gt;prior = s;</span></span>
<span class="line"><span>    s-&gt;prior = p;</span></span>
<span class="line"><span>    p-&gt;next = s;    </span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>按位序插入操作</li></ul><p>思路：从头结点开始，找到某个位序的前驱结点，对该前驱结点执行后插操作；</p><ul><li>前插操作</li></ul><p>思路：找到给定结点的前驱结点，再对该前驱结点执行后插操作；</p><ol><li>双链表的删除操作</li></ol><p>删除p的后继结点q</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>p-&gt;next = q-&gt;next;</span></span>
<span class="line"><span>q-&gt;next-&gt;prior = p;</span></span>
<span class="line"><span>free(q);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要删除的结点q是最后一个结点，会出现错误，故增加条件判断以提高代码健壮性<br> 代码实现 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//删除p结点的后继结点</span></span>
<span class="line"><span>bool DeletNextDNode(DNode *p){</span></span>
<span class="line"><span>    if(p==NULL) </span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    DNode *q = p-&gt;next;            //找到p的后继结点q</span></span>
<span class="line"><span>    if(q==NULL)</span></span>
<span class="line"><span>        return false;     //p没有后继结点;</span></span>
<span class="line"><span>    p-&gt;next=q-&gt;next;</span></span>
<span class="line"><span>    if(q-&gt;next != NULL)           //q结点不是最后一个结点</span></span>
<span class="line"><span>        q-&gt;next-&gt;prior=p;</span></span>
<span class="line"><span>    free(q);</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//销毁一个双链表</span></span>
<span class="line"><span>void DestoryList(DLinklist &amp;L){</span></span>
<span class="line"><span>    //循环释放各个数据结点</span></span>
<span class="line"><span>    while(L-&gt;next != NULL)</span></span>
<span class="line"><span>        DeletNextDNode(L);    //删除头结点的后继结点</span></span>
<span class="line"><span>    free(L);       //释放头结点</span></span>
<span class="line"><span>    L=NULL;        //头指针指向NULL</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>双链表的遍历操作<strong>后向遍历</strong></li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>while(p!=NULL){</span></span>
<span class="line"><span>    //对结点p做相应处理，如打印</span></span>
<span class="line"><span>    p = p-&gt;next;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>前向遍历</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>while(p!=NULL){</span></span>
<span class="line"><span>    //对结点p做相应处理，如打印</span></span>
<span class="line"><span>    p = p-&gt;prior;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们不想处理头结点，那就跳过头结点！</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>while(p-&gt;prior!=NULL){</span></span>
<span class="line"><span>    //对结点p做相应处理</span></span>
<span class="line"><span>    p = p-&gt;prior;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：双链表不可随机存取，按位查找和按值查找操作都只能用遍历的方式实现，时间复杂度为<strong>O(n)</strong></p><h3 id="_2-3-4-循环链表" tabindex="-1"><a class="header-anchor" href="#_2-3-4-循环链表"><span><strong>2.3.4 循环链表</strong></span></a></h3><p><strong>1. 循环单链表</strong></p><p><strong>最后一个结点的指针不是NULL,而是指向头结点hedui</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct LNode{         //定义单链表类型   </span></span>
<span class="line"><span>    ElemType data;             //每个节点存放一个数据元素  </span></span>
<span class="line"><span>    struct LNode *next;        //指针指向下一个节点</span></span>
<span class="line"><span>}LNode, *Linklist;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//初始化一个循环单链表</span></span>
<span class="line"><span>bool InitList(LinkList &amp;L){</span></span>
<span class="line"><span>    L = (LNode *)malloc(sizeof(LNode));     //分配一个头结点</span></span>
<span class="line"><span>    if(L==NULL)               //内存不足，分配失败</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    L-&gt;next = L;              //头结点next指针指向头结点</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//判断循环单链表是否为空</span></span>
<span class="line"><span>bool Empty(LinkList L){</span></span>
<span class="line"><span>    if(L-&gt;next == L)</span></span>
<span class="line"><span>        return true;    //为空</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//判断结点p是否为循环单链表的表尾结点</span></span>
<span class="line"><span>bool isTail(LinkList L, LNode *p){</span></span>
<span class="line"><span>    if(p-&gt;next == L)</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="单链表-循环单链表" tabindex="-1"><a class="header-anchor" href="#单链表-循环单链表"><span><strong>单链表 &amp; 循环单链表</strong></span></a></h2><ul><li><p><strong>单链表</strong>：从一个结点出发只能找到该结点后续的各个结点；对链表的操作大多都在头部或者尾部；设立头指针，从头结点找到尾部的时间复杂度=O(n)，即对表尾进行操作需要O(n)的时间复杂度;</p></li><li><p><strong>循环单链表</strong>：从一个结点出发，可以找到其他任何一个结点；设立尾指针，从尾部找到头部的时间复杂度为O(1)，即对表头和表尾进行操作都只需要O(1)的时间复杂度;</p></li></ul><blockquote><p>可以让L指向表尾元素(插入，删除时可能需要修改L)<br><strong>2. 循环双链表</strong></p></blockquote><p><strong>表头结点的</strong><code>prior</code>指向表尾结点，表尾结点的<code>next</code>指向头结点</p><p>循环双链表的初始化 hedui</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct DNode{          </span></span>
<span class="line"><span>    ElemType data;               </span></span>
<span class="line"><span>    struct DNode *prior, *next;  </span></span>
<span class="line"><span>}DNode, *DLinklist;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//初始化空的循环双链表</span></span>
<span class="line"><span>bool InitDLinkList(DLinklist &amp;L){</span></span>
<span class="line"><span>    L = (DNode *) malloc(sizeof(DNode));    //分配一个头结点</span></span>
<span class="line"><span>    if(L==NULL)            //内存不足，分配失败</span></span>
<span class="line"><span>        return false;  </span></span>
<span class="line"><span>    L-&gt;prior = L;          //头结点的prior指向头结点</span></span>
<span class="line"><span>    L-&gt;next = L;           //头结点的next指向头结点</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void testDLinkList(){</span></span>
<span class="line"><span>    //初始化循环单链表</span></span>
<span class="line"><span>    DLinklist L;</span></span>
<span class="line"><span>    InitDLinkList(L);</span></span>
<span class="line"><span>    //...后续代码</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//判断循环双链表是否为空</span></span>
<span class="line"><span>bool Empty(DLinklist L){</span></span>
<span class="line"><span>    if(L-&gt;next == L)</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//判断结点p是否为循环双链表的表尾结点</span></span>
<span class="line"><span>bool isTail(DLinklist L, DNode *p){</span></span>
<span class="line"><span>    if(p-&gt;next == L)</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="双链表-循环双链表" tabindex="-1"><a class="header-anchor" href="#双链表-循环双链表"><span><strong>双链表 &amp; 循环双链表</strong></span></a></h2><ul><li><strong>插入操作</strong></li></ul><p>对于循环双链表，操作 <code>p-&gt;next-&gt;prior = s</code> 不会出问题辣！因为就算p是最后一个结点，也不会出现空指针现象了(这个问题在双链表里会出现！)</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>bool InsertNextDNode(DNode *p, DNode *s){ </span></span>
<span class="line"><span>    s-&gt;next = p-&gt;next;          //将结点*s插入到结点*p之后</span></span>
<span class="line"><span>    p-&gt;next-&gt;prior = s;</span></span>
<span class="line"><span>    s-&gt;prior = p;</span></span>
<span class="line"><span>    p-&gt;next = s;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>删除操作</strong></li></ul><p>和插入操作一样！<code>q-&gt;next-&gt;prior</code> 对于循环双链表不会出错了</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//删除p的后继结点q</span></span>
<span class="line"><span>p-&gt;next = q-&gt;next;</span></span>
<span class="line"><span>q-&gt;next-&gt;prior = p;</span></span>
<span class="line"><span>free(q);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-5-静态链表" tabindex="-1"><a class="header-anchor" href="#_2-3-5-静态链表"><span><strong>2.3.5 静态链表</strong></span></a></h3><ol><li>何为静态链表</li></ol><ul><li><p>单链表: 各个结点散落在内存中的各个角落，每个结点有指向下一个节点的指针(下一个结点在内存中的地址);</p></li><li><p>静态链表——用数组的方式实现的链表: 分配一整片连续的内存空间，各个结点集中安置，包括了——数据元素and下一个结点的数组下标(游标)</p><ul><li><p>其中数组下标为0的结点充当&quot;头结点&quot;</p></li><li><p>游标为-1表示已经到达表尾</p></li><li><p>若每个数据元素为4B，每个游标为4B，则每个结点共8B；假设起始地址为<code>addr</code>，则数据下标为2的存放地址为：<code>addr</code>+8*2</p></li><li><p><strong>注意</strong>： 数组下标——物理顺序，位序——逻辑顺序；</p></li><li><p>优点：增、删操作不需要大量移动元素；</p></li><li><p>缺点：不能随机存取，只能从头结点开始依次往后查找，<strong>容量固定不变！</strong></p></li></ul></li></ul><ol><li>代码定义一个静态链表 hedui</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define MaxSize 10        //静态链表的最大长度</span></span>
<span class="line"><span>struct Node{              //静态链表结构类型的定义</span></span>
<span class="line"><span>    ElemType data;        //存储数据元素</span></span>
<span class="line"><span>    int next;             //下一个元素的数组下标</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//用数组定义多个连续存放的结点</span></span>
<span class="line"><span>void testSLinkList(){</span></span>
<span class="line"><span>    struct Node a[MaxSize];  //每一个数组元素的类型都是struct Node</span></span>
<span class="line"><span>    //...后续代码</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以这样：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define MaxSize 10        //静态链表的最大长度</span></span>
<span class="line"><span>typedef struct{           //静态链表结构类型的定义</span></span>
<span class="line"><span>    ELemType data;        //存储数据元素</span></span>
<span class="line"><span>    int next;             //下一个元素的数组下标</span></span>
<span class="line"><span>}SLinkList[MaxSize];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void testSLinkList(){</span></span>
<span class="line"><span>    SLinkList a;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个代码等同于</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define MaxSize 10        //静态链表的最大长度</span></span>
<span class="line"><span>struct Node{              //静态链表结构类型的定义</span></span>
<span class="line"><span>    ElemType data;        //存储数据元素</span></span>
<span class="line"><span>    int next;             //下一个元素的数组下标</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//重命名struct Node，用SLinkList定义一个长度为MaxSize的Node型数组;</span></span>
<span class="line"><span>typedef struct Node SLinkList[MaxSize];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PS: <code>SLinkList a</code> 强调a是静态链表；<code>struct Node a</code> 强调a是一个Node型数组；</p><ol><li>静态链表基本操作的实现</li></ol><ul><li><p>初始化静态链表：把<code>a[0]</code>的<code>next</code>设为-1</p></li><li><p>查找某个位序（不是数组下标，位序是各个结点在逻辑上的顺序）的结点：从头结点出发挨个往后遍历结点，时间复杂度O=(n)</p></li><li><p>在位序为i上插入结点：① 找到一个空的结点，存入数据元素；② 从头结点出发找到位序为i-1的结点；③修改新结点的next；④ 修改i-1号结点的next；</p></li></ul><blockquote><p>Q：如何判断结点为空？<br> A：在初始化时，将空闲结点的next设置为某个特殊值，eg：-2；</p></blockquote><ul><li>删除某个结点：① 从头结点出发找到前驱结点；② 修改前驱节点的游标；③ 被删除节点next设为-2；</li></ul><h3 id="_2-3-6-顺序表和链表的比较" tabindex="-1"><a class="header-anchor" href="#_2-3-6-顺序表和链表的比较"><span><strong>2.3.6 顺序表和链表的比较</strong></span></a></h3><p><strong>1. 逻辑结构</strong></p><ul><li>顺序表和链表都属于线性表，都是线性结构</li></ul><p><strong>2. 存储结构</strong></p><ul><li><p>顺序表：顺序存储</p><ul><li><p>优点：支持随机存取，存储密度高</p></li><li><p>缺点：大片连续空间分配不方便，改变容量不方便</p></li></ul></li><li><p>链表：链式存储</p><ul><li><p>优点：离散的小空间分配方便，改变容量方便</p></li><li><p>缺点：不可随机存取，存储密度低</p></li></ul></li></ul><p><strong>3. 基本操作 - 创</strong></p><ul><li><p>顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源；</p><ul><li><p>静态分配：静态数组，容量不可改变</p></li><li><p>动态分配：动态数组，容量可以改变，但是需要移动大量元素，时间代价高（<code>malloc()</code>,<code>free()</code>）</p></li></ul></li><li><p>链表：只需要分配一个头结点或者只声明一个头指针，之后方便拓展</p></li></ul><p><strong>4. 基本操作 - 销毁</strong></p><ul><li>顺序表：修改 <code>Length</code> = 0</li></ul><p>静态分配：静态数组——系统自动回收空间</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct{</span></span>
<span class="line"><span>    ElemType *data;</span></span>
<span class="line"><span>    int MaxSize;</span></span>
<span class="line"><span>    int length;</span></span>
<span class="line"><span>}SeqList;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>动态分配：动态数组——需要手动free</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//创</span></span>
<span class="line"><span>L.data = (ELemType *)malloc(sizeof(ElemType) *InitSize)</span></span>
<span class="line"><span>//销</span></span>
<span class="line"><span>free(L.data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//！malloc() 和 free() 必须成对出现</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>链表：依次删除各个结点 <code>free()</code></li></ul><p><strong>5. 基本操作 - 增/删</strong></p><ul><li><p>顺序表：插入/删除元素要将后续元素后移/前移；时间复杂度=O(n)，时间开销主要来自于移动元素；</p></li><li><p>链表：插入/删除元素只需要修改指针；时间复杂度=O(n)，时间开销主要来自查找目标元素</p></li></ul><p><strong>6. 基本操作 - 查</strong></p><ul><li><p>顺序表</p><ul><li><p>按位查找：O(1)</p></li><li><p>按值查找：O(n)，若表内元素有序，可在O(log2n)时间内找到</p></li></ul></li><li><p>链表：</p><ul><li><p>按位查找：O(n)</p></li><li><p>按值查找：O(n)</p></li></ul></li></ul><p><strong>7. 开放式问题答题思路</strong></p><p><strong>Q:</strong> 请描述顺序表和链表的balabalabala…实现线性表时，用顺序表还是链表好？</p><p><strong>A:</strong> 顺序表和链表的<strong>存储结构</strong>都是线性结构，都属于线性表；但是二者的<strong>存储结构</strong>不同，顺序表采用顺序存储…(特点，优缺点)；链表采用链式存储…(特点，优缺点)；由于采用不同的存储方式实现，因此<strong>基本操作</strong>的实现效率也不同；当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…；</p></div><!----><!----><!--[--><h2 id="doc-contributors" tabindex="-1"><a href="#doc-contributors" class="header-anchor"><span>贡献者</span></a></h2><div class="vp-contributors"><a href="https://github.com/hupei" target="_blank" rel="noreferrer" class="vp-contributor"><!----><span class="vp-contributor-name">hupei</span></a></div><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">最近更新：</span><time class="vp-meta-info" datetime="2025-09-04T11:21:57.000Z" data-allow-mismatch>2025/9/4 11:21</time></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/cs/data-structure/introduction.html" aria-label="绪论" iconsizing="both"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->绪论</div></a><a class="route-link auto-link next" href="/cs/data-structure/stack-queue.html" aria-label="栈与队列" iconsizing="both"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">栈与队列<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">Powered By HuPei</div><div class="vp-copyright">Copyright © 2025 HuPei </div></footer></div><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-Bmvlbfib.js" defer></script>
  </body>
</html>
