## redis数据类型

**核心数据类型** (5种)

1. **String (字符串)**： 最简单的类型，可存文本、整数或浮点数，二进制安全。支持自增/自减操作。
2. **Hash (哈希)**： 字段-值对的集合，非常适合存储对象。
3. **List (列表)**： 按插入顺序排序的字符串元素列表，基于双向链表实现，可用作栈或队列。
4. **Set (集合)**： 无序的、元素唯一的字符串集合，支持交集、并集、差集等运算。
5. **Sorted Set (有序集合)**： 类似 Set，但每个元素关联一个分数(score)，按分数排序，元素唯一，适用于排行榜。

------

**扩展数据类型** (基于核心类型实现)

1. **Bitmaps (位图)**： 本质是 String，提供位级别的操作（如设置、统计）。极其节省空间，适用于二值状态统计（如用户签到）。
2. **HyperLogLogs (基数统计)**： 本质是 String，用于估计一个集合中不重复元素的基数（数量）。提供近似去重计数，标准误差 <1%，极其节省内存。
3. **Streams (流)**： 本质是 List 的增强版，提供了一个完整的、支持多消费者的消息队列功能。支持消息持久化、消费者组、消息确认机制。
4. **Geo(地理坐标)**：Redis3.2 推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作。



**为什么String类型用SDS实现，而不是C字符串？**
SDS (Simple Dynamic String) 相比C原生字符串有巨大优势：

- **O(1)获取长度**：SDS有`len`属性，直接获取字符串长度，而C字符串需要遍历。
- **避免缓冲区溢出**：SDS API会先检查空间是否足够，不足则自动扩展。
- **二进制安全**：SDS可以存储任意二进制数据，包括`\0`，因为它靠`len`判断结束，而不是空字符。
- **内存预分配**：减少修改字符串时带来的内存重分配次数。



**ZSet的底层实现是什么？为什么用跳跃表？**

- **底层实现**：**跳跃表 (skiplist) + 哈希表 (dict)** 的混合结构。
- **为什么用跳跃表**：
  1. **支持范围查询**：跳跃表基于排序的链表结构，可以高效地实现 `ZRANGE`, `ZRANK` 等范围操作，效率远高于平衡树。
  2. **实现相对简单**：比平衡树（如AVL、红黑树）更容易实现和调试。
  3. **平均性能好**：插入、删除、查找的平均时间复杂度都是 **O(log N)**，性能与平衡树相当。



**Redis有哪些持久化方式？**

- **RDB (快照)**：在指定时间间隔生成数据的二进制快照。**优点**：文件小，恢复快。**缺点**：可能丢失最后一次快照后的数据。
- **AOF (追加日志)**：记录每一个写操作命令。**优点**：数据完整性高，最多丢失1秒数据。**缺点**：文件大，恢复慢。
- **混合持久化** (4.0+)：结合两者，AOF文件包含RDB头和增量AOF日志，兼顾速度和数据安全。**生产环境推荐**。



## Redis 高性能的原因

1. **基于内存**： 数据主要存储在内存中，读写操作直接操作内存，避免了磁盘 I/O 瓶颈。
2. **单线程架构**：
   - 避免了多线程的上下文切换和竞争开销。
   - 保证了原子操作的线程安全，简化了数据结构的实现。
3. **高效的数据结构**：
   - 设计了多种精心优化的底层数据结构（如 SDS、跳跃表、压缩列表等），最大限度利用内存并减少操作时间。
4. **I/O 多路复用**：
   - 使用 `epoll` 等机制处理大量连接，保证在单线程下也能高效进行网络 I/O。
5. **其他优化**：
   - **虚拟内存机制**： 应对物理内存不足。
   - **渐进式 rehash**： 在扩容时避免长时间阻塞。

**总结**： Redis为基于内存的非关系型数据库，故瓶颈不在CPU，而是内存和网络IO。**内存访问 + 单线程避免竞争 + I/O 多路复用 + 优化数据结构** 共同造就了其极致性能。



## Redis 持久化机制

Redis 提供两种核心持久化机制：**RDB** 和 **AOF**，可单独或组合使用，确保数据在重启后不丢失。

### RDB（Redis Database）

RDB全称（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是在指定时间间隔内，将内存中的数据集生成一个**全量快照**，存储到二进制压缩文件（默认 `dump.rdb`）。

**执行时机**：

- **手动触发**：`SAVE`（同步阻塞）或 `BGSAVE`（后台异步）。

- **自动触发**：通过redis.conf配置规则（如 `save 900 1` 表示 900 秒内至少 1 个键变更则触发 `BGSAVE`）。

- **关机时**：如果开启了RDB，正常关闭服务时会自动执行一次`SAVE`。

  

**RDB bgsave 基本流程**

1. **Fork子进程**：主进程创建一个子进程，仅 `fork` 时有短暂阻塞。
2. **子进程写文件**：子进程把当前内存中的数据**复制**并写入到一个**新的临时RDB文件**中。
3. **替换旧文件**：写完後，用新文件**替换**掉旧的RDB文件。



**RDB的缺点**

1. **丢数据风险**：因为每隔一段时间才备份一次，如果中途宕机，**从上一次备份到宕机时的数据会丢失**。

2. **性能影响**：虽然`bgsave`是后台操作，但**fork子进程**的过程可能会阻塞主进程，尤其是数据量很大时。

   

> **save 60 1000 代表什么？**
>
> 代表：在 **60秒内**，如果发生了至少 **1000次数据修改**，则自动触发一次 `BGSAVE`。



### AOF (Append Only File)

AOF全称为Append Only File（追加文件）。以命令日志文件的形式，记录Redis处理的每一个写命令，重启服务时重新执行这些命令来恢复数据。

**执行流程**

1. **命令追加**：写命令执行后追加到 AOF 缓冲区。
2. **文件写入**：根据 `appendfsync` 策略将缓冲区内容写入内核页面缓存。
3. **文件同步**：根据策略将内核缓存数据同步（`fsync`）到磁盘。



**执行时机，appendfsync 策略**	

- **always**：每个写命令同步到磁盘。最安全，性能最低。
- **everysec（默认）**：每秒同步一次。均衡策略，最多丢失 1 秒数据。
- **no**：由操作系统决定同步时机。性能最好，数据最不安全。

~~~bash
 #表示每执行一次写命令，立即记录到AOF文件 
appendfsync always
#写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案。
appendfsync everysec 
#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 
appendfsync no
~~~
